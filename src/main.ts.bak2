import { on, once, showUI } from '@create-figma-plugin/utilities'

import { BRAND } from './core/brand'
import { CONFIG } from './core/config'
import { getDefaultAssistant, getAssistant, listAssistants } from './assistants'
import type { Assistant } from './assistants'
import { createProvider } from './core/provider/providerFactory'
import type { Provider, ChatRequest } from './core/provider/provider'
import { normalizeMessages } from './core/provider/normalize'
import { routeToolCall } from './core/tools/toolRouter'
import { summarizeSelection } from './core/context/selection'
import { buildSelectionContext } from './core/context/selectionContext'
import { createTextFrameOnCanvas } from './core/figma/createTextFrameOnCanvas'
import { renderScorecard } from './core/figma/renderScorecard'
import type { ScorecardData } from './core/figma/renderScorecard'
import { saveSettings, getSettings } from './core/settings'
import { ProxyError } from './core/proxy/client'
import { ProviderError, ProviderErrorType } from './core/provider/provider'
import type {
  ResetHandler,
  RequestSelectionStateHandler,
  RequestSettingsHandler,
  SendMessageHandler,
  SetAssistantHandler,
  SetModeHandler,
  SetLlmProviderHandler,
  RunQuickActionHandler,
  RunToolHandler,
  SaveSettingsHandler,
  TestProxyConnectionHandler,
  ResetDoneHandler,
  SelectionStateHandler,
  AssistantMessageHandler,
  ToolResultHandler,
  TestResultHandler,
  SettingsResponseHandler,
  ScorecardPlacedHandler,
  ScorecardResult,
  UniversalContentTableV1,
  Message,
  SelectionState,
  LlmProviderId,
  ToolCall,
  CopyTableStatusHandler,
  ExportContentTableRefImageHandler
} from './core/types'
import { scanContentTable } from './core/contentTable/scanner'

/**
 * Convert an error to a human-readable string with actionable feedback
 * Uses ProviderError for consistent error handling across all providers
 */
function errorToString(error: unknown): string {
  // Handle ProviderError (includes ProxyError which extends it)
  if (error instanceof ProviderError) {
    // Provide actionable error messages based on error type
    switch (error.type) {
      case ProviderErrorType.AUTHENTICATION:
        return 'Authentication failed. Please check your token in Settings.'
      case ProviderErrorType.RATE_LIMIT:
        return 'Rate limit exceeded. Please try again in a moment.'
      case ProviderErrorType.NETWORK:
        return `Network error: ${error.message}`
      case ProviderErrorType.TIMEOUT:
        return 'Request timeout. The server took too long to respond. Please try again.'
      case ProviderErrorType.INVALID_REQUEST:
        return `Invalid request: ${error.message}`
      case ProviderErrorType.PROVIDER_ERROR:
        if (error.statusCode && error.statusCode >= 500) {
          return `Server error (${error.statusCode}): The server encountered an error. Please try again later.`
        }
        return `Provider error: ${error.message}`
      default:
        return error.message
    }
  }
  
  if (error instanceof Error) {
    return error.message
  }
  
  if (error && typeof error === 'object' && 'status' in error && 'statusText' in error) {
    const response = error as { status: number; statusText: string }
    return `HTTP ${response.status}: ${response.statusText}`
  }
  
  if (error && typeof error === 'object') {
    try {
      const stringified = JSON.stringify(error, null, 2)
      return stringified.length > 500 ? stringified.substring(0, 500) + '...' : stringified
    } catch {
      return String(error)
    }
  }
  
  return String(error)
}

// State
let currentAssistant: Assistant = getDefaultAssistant()
let currentMode: 'simple' | 'advanced' = CONFIG.defaultMode
let currentProviderId: LlmProviderId = CONFIG.provider
let currentProvider: Provider | null = null
let messageHistory: Message[] = []
let selectionOrder: string[] = []

// Initialize provider
async function initializeProvider() {
  try {
    currentProvider = await createProvider(currentProviderId)
  } catch (error) {
    console.error('[Main] Failed to initialize provider:', error)
    // Fallback to stub provider
    const { StubProvider } = await import('./core/provider/stubProvider')
    currentProvider = new StubProvider()
  }
}

// Initialize on startup
initializeProvider()

// Generate unique message ID
function generateMessageId(): string {
  return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

// Send selection state to UI
function sendSelectionState() {
  const state = summarizeSelection(selectionOrder)
  figma.ui.postMessage({ pluginMessage: { type: 'SELECTION_STATE', state } })
}

// Send assistant message to UI
function sendAssistantMessage(content: string, toolCallId?: string) {
  const message: Message = {
    id: generateMessageId(),
    role: 'assistant',
    content,
    timestamp: Date.now(),
    toolCallId
  }
  messageHistory.push(message)
  
  figma.ui.postMessage({ pluginMessage: { type: 'ASSISTANT_MESSAGE', message } })
}

// Send tool result to UI
function sendToolResult(content: string, toolId: string, data?: Record<string, unknown>) {
  const message: Message = {
    id: generateMessageId(),
    role: 'tool',
    content,
    timestamp: Date.now(),
    toolCallId: toolId
  }
  messageHistory.push(message)
  
  figma.ui.postMessage({ pluginMessage: { type: 'TOOL_RESULT', message, data } })
}

// Handle reset
once<ResetHandler>('RESET', async function () {
  messageHistory = []
  currentAssistant = getDefaultAssistant()
  currentMode = CONFIG.defaultMode
  currentProviderId = CONFIG.provider
  currentProvider = await createProvider(currentProviderId)
  selectionOrder = []
  
  // Send assistant intro on reset
  const introMessage: Message = {
    id: generateMessageId(),
    role: 'assistant',
    content: currentAssistant.intro,
    timestamp: Date.now()
  }
  messageHistory.push(introMessage)
  figma.ui.postMessage({ pluginMessage: { type: 'ASSISTANT_MESSAGE', message: introMessage } })
  
  sendSelectionState()
  
  figma.ui.postMessage({ pluginMessage: { type: 'RESET_DONE' } })
})

// Handle selection state request
on<RequestSelectionStateHandler>('REQUEST_SELECTION_STATE', function () {
  console.log('[Main] onmessage REQUEST_SELECTION_STATE')
  sendSelectionState()
})

// Handle set assistant
on<SetAssistantHandler>('SET_ASSISTANT', function (assistantId: string) {
  console.log('[Main] onmessage SET_ASSISTANT', { assistantId })
  const assistant = getAssistant(assistantId)
  if (assistant) {
    currentAssistant = assistant
    // Send assistant intro message
    const introMessage: Message = {
      id: generateMessageId(),
      role: 'assistant',
      content: assistant.intro,
      timestamp: Date.now()
    }
    messageHistory.push(introMessage)
    console.log('[Main] postMessage ASSISTANT_MESSAGE (assistant intro)')
    figma.ui.postMessage({ pluginMessage: { type: 'ASSISTANT_MESSAGE', message: introMessage } })
  }
})

// Handle set mode
on<SetModeHandler>('SET_MODE', function (mode: 'simple' | 'advanced') {
  currentMode = mode
})

// Handle set LLM provider
on<SetLlmProviderHandler>('SET_LLM_PROVIDER', async function (providerId: LlmProviderId) {
  currentProviderId = providerId
  currentProvider = await createProvider(providerId)
})

// Handle send message
on<SendMessageHandler>('SEND_MESSAGE', async function (message: string, includeSelection?: boolean) {
  console.log('[Main] onmessage SEND_MESSAGE', { messageLength: message.length, includeSelection })
  // Add user message to history
  const userMessage: Message = {
    id: generateMessageId(),
    role: 'user',
    content: message,
    timestamp: Date.now()
  }
  messageHistory.push(userMessage)
  
  // Build selection context if needed
  let selectionContext: Awaited<ReturnType<typeof buildSelectionContext>> | undefined
  if (includeSelection && currentProvider) {
    selectionContext = await buildSelectionContext({
      selectionOrder,
      quickAction: undefined, // No quick action for manual messages
      provider: currentProvider
    })
  }
  
  // Handle tool-only assistants
  if (currentAssistant.kind === 'tool') {
    sendAssistantMessage(`Tool-only assistant "${currentAssistant.label}" is active. Tool execution would happen here.`)
    return
  }
  
  // Build chat messages (role/content only, no system messages)
  // Filter and normalize messages for provider
  const chatMessages = normalizeMessages(
    messageHistory
      .filter(m => m.role === 'user' || m.role === 'assistant')
      .map(m => ({
        role: m.role,
        content: m.content
      }))
  )
  
  // Call provider
  try {
    if (!currentProvider) {
      currentProvider = await createProvider(currentProviderId)
      // Rebuild context if provider was just created
      if (includeSelection) {
        selectionContext = await buildSelectionContext({
          selectionOrder,
          quickAction: undefined,
          provider: currentProvider
        })
      }
    }
    const response = await currentProvider.sendChat({
      messages: chatMessages,
      assistantId: currentAssistant.id,
      assistantName: currentAssistant.label,
      selection: selectionContext?.selection,
      selectionSummary: selectionContext?.selectionSummary,
      images: selectionContext?.images,
      quickActionId: undefined
    })
    
    sendAssistantMessage(response)
  } catch (error) {
    const errorMessage = errorToString(error)
    sendAssistantMessage(`Error: ${errorMessage}`)
  }
})

/**
 * Parse Design Critique markdown into scorecard schema
 * Handles common markdown patterns: scores, sections, lists
 */
function parseDesignCritiqueMarkdown(raw: string): ScorecardResult | null {
  try {
    const text = raw.trim()
    if (!text) return null
    
    // Extract overall score (handle various formats)
    let overallScore = 50 // Default if not found
    const scorePatterns = [
      /(?:overall|total)\s*score[:\s]*(\d+(?:\.\d+)?)\s*(?:\/|\s*out\s*of)\s*10/i,
      /(?:overall|total)\s*score[:\s]*(\d+(?:\.\d+)?)\s*(?:\/|\s*out\s*of)\s*100/i,
      /####\s*(?:overall|total)\s*score[:\s]*(\d+(?:\.\d+)?)/i,
      /###\s*(?:overall|total)\s*score[:\s]*(\d+(?:\.\d+)?)/i,
      /##\s*(?:overall|total)\s*score[:\s]*(\d+(?:\.\d+)?)/i,
      /#\s*(?:overall|total)\s*score[:\s]*(\d+(?:\.\d+)?)/i,
      /score[:\s]*(\d+(?:\.\d+)?)\s*(?:\/|\s*out\s*of)\s*10/i,
      /score[:\s]*(\d+(?:\.\d+)?)\s*(?:\/|\s*out\s*of)\s*100/i
    ]
    
    for (const pattern of scorePatterns) {
      const match = text.match(pattern)
      if (match) {
        const score = parseFloat(match[1])
        if (!isNaN(score)) {
          // Convert 0-10 scale to 0-100 if needed
          if (score <= 10 && pattern.source.includes('10')) {
            overallScore = Math.round(score * 10)
          } else if (score <= 100) {
            overallScore = Math.round(score)
          }
          break
        }
      }
    }
    
    // Extract sections using heading patterns
    const extractSection = (sectionName: string, text: string): string[] => {
      const patterns = [
        new RegExp(`(?:^|\\n)#{1,6}\\s*${sectionName}[:\\s]*\\n([\\s\\S]*?)(?=\\n#{1,6}|$)`, 'i'),
        new RegExp(`(?:^|\\n)##?\\s*${sectionName}[:\\s]*\\n([\\s\\S]*?)(?=\\n#{1,6}|$)`, 'i'),
        new RegExp(`(?:^|\\n)###?\\s*${sectionName}[:\\s]*\\n([\\s\\S]*?)(?=\\n#{1,6}|$)`, 'i'),
        new RegExp(`(?:^|\\n)${sectionName}[:\\s]*\\n([\\s\\S]*?)(?=\\n(?:#{1,6}|[A-Z][a-z]+[:\\s]*\\n)|$)`, 'i')
      ]
      
      for (const pattern of patterns) {
        const match = text.match(pattern)
        if (match) {
          const content = match[1].trim()
          if (content) {
            // Extract list items (numbered or bulleted)
            const items: string[] = []
            const lines = content.split('\n')
            
            for (const line of lines) {
              const trimmed = line.trim()
              if (!trimmed) continue
              
              // Match numbered lists: 1. item, 2. item
              const numberedMatch = trimmed.match(/^\d+\.\s*(.+)$/)
              if (numberedMatch) {
                items.push(numberedMatch[1].trim())
                continue
              }
              
              // Match bullet lists: - item, • item, * item
              const bulletMatch = trimmed.match(/^[-•*]\s+(.+)$/)
              if (bulletMatch) {
                items.push(bulletMatch[1].trim())
                continue
              }
              
              // If line doesn't start with list marker but is not empty, include it
              if (trimmed && !trimmed.match(/^#{1,6}\s/)) {
                items.push(trimmed)
              }
            }
            
            return items.filter(item => item.length > 0)
          }
        }
      }
      
      return []
    }
    
    const wins = extractSection('wins?', text)
    const fixes = extractSection('fixes?|improvements?|issues?', text)
    const checklist = extractSection('checklist|next\\s*steps?|actions?', text)
    const notes = extractSection('notes?|observations?|other', text)
    
    // Generate summary from first paragraph or first few lines
    let summary = ''
    const firstParagraph = text.split('\n\n')[0] || text.split('\n').slice(0, 3).join(' ')
    if (firstParagraph && !firstParagraph.match(/^(overall|total)\s*score/i)) {
      summary = firstParagraph.trim().substring(0, 200)
    } else {
      summary = `Design critique with score ${overallScore}/100`
    }
    
    // Create items array from wins and fixes (for schema compatibility)
    const items: Array<{ label: string; score: number; outOf: number; notes: string }> = []
    
    // Add wins as high-scoring items
    wins.forEach(win => {
      items.push({
        label: win.substring(0, 50),
        score: 4,
        outOf: 5,
        notes: win
      })
    })
    
    // Add fixes as low-scoring items
    fixes.forEach(fix => {
      items.push({
        label: fix.substring(0, 50),
        score: 2,
        outOf: 5,
        notes: fix
      })
    })
    
    // If no items, create a default item
    if (items.length === 0) {
      items.push({
        label: 'Overall Design',
        score: Math.round(overallScore / 20), // Convert 0-100 to 0-5 scale
        outOf: 5,
        notes: summary
      })
    }
    
    return {
      type: 'scorecard',
      version: 1,
      summary: summary,
      overallScore: overallScore,
      items: items,
      risks: fixes.length > 0 ? fixes.slice(0, 5) : [], // Use fixes as risks
      actions: checklist.length > 0 ? checklist : fixes.slice(0, 5) // Use checklist or fixes as actions
    }
  } catch (error) {
    console.error('[DesignCritique] Markdown parser error:', error)
    return null
  }
}

/**
 * Repair Design Critique response by converting markdown/text to JSON
 * Makes a second LLM call with a focused prompt to extract/convert to scorecard JSON
 */
async function repairDesignCritiqueToJson(rawText: string, provider: Provider): Promise<string> {
  const repairPrompt = `Convert the following design critique into a JSON object matching this exact schema:

{
  "type": "scorecard",
  "version": 1,
  "summary": "1-2 sentences summarizing overall design quality",
  "overallScore": 0-100,
  "items": [
    { "label": "Dimension name", "score": 0-5, "outOf": 5, "notes": "Brief notes" }
  ],
  "risks": ["Risk 1", "Risk 2"],
  "actions": ["Action 1", "Action 2"]
}

Design critique text:
${rawText}

Output ONLY a valid JSON object. No markdown, no code fences, no commentary.`

  const repairMessages: ChatRequest['messages'] = [
    {
      role: 'user',
      content: repairPrompt
    }
  ]
  
  console.log('[Main] Sending repair request to provider...')
  const repaired = await provider.sendChat({
    messages: repairMessages,
    assistantId: 'design_critique',
    assistantName: 'Design Critique',
    quickActionId: undefined
  })
  
  return repaired
}

// Handle quick action
on<RunQuickActionHandler>('RUN_QUICK_ACTION', async function (actionId: string, assistantId: string) {
  console.log('[Main] onmessage RUN_QUICK_ACTION', { actionId, assistantId })
  try {
  const assistant = getAssistant(assistantId)
  if (!assistant) {
      console.error('[Main] Assistant not found:', assistantId)
      sendAssistantMessage(`Error: Assistant "${assistantId}" not found`)
    return
  }
  
  const action = assistant.quickActions.find((a: import('./assistants').QuickAction) => a.id === actionId)
  if (!action) {
      console.error('[Main] Action not found:', actionId, 'for assistant:', assistantId)
      sendAssistantMessage(`Error: Action "${actionId}" not found`)
    return
    }
  
  // Special handling for Content Table assistant
  if (assistantId === 'content_table') {
    if (actionId === 'generate-table') {
      // Validate selection: must be exactly one container
      if (selectionOrder.length === 0) {
        const errorMsg = 'Select a single container to scan.'
        sendAssistantMessage(errorMsg)
        figma.notify(errorMsg)
        return
      }
      
      if (selectionOrder.length > 1) {
        const errorMsg = 'Only one selection allowed. Select a single container.'
        sendAssistantMessage(errorMsg)
        figma.notify(errorMsg)
        return
      }
      
      // Get the selected node
      const selectedNode = figma.getNodeById(selectionOrder[0])
      if (!selectedNode) {
        const errorMsg = 'Selected node not found.'
        sendAssistantMessage(errorMsg)
        figma.notify(errorMsg)
        return
      }
      
      // Validate it's a valid container (not DOCUMENT or PAGE)
      if (selectedNode.type === 'DOCUMENT' || selectedNode.type === 'PAGE') {
        const errorMsg = 'Please select a container (frame, component, etc.), not a page or document.'
        sendAssistantMessage(errorMsg)
        figma.notify(errorMsg)
        return
      }
      
      try {
        // Send "Scanning..." message
        sendAssistantMessage('Scanning...')
        
        // Scan the container (now async for thumbnail export)
        const contentTable = await scanContentTable(selectedNode as SceneNode)
        
        // Send success message
        const itemCount = contentTable.items.length
        if (itemCount === 0) {
          sendAssistantMessage('No text items found in the selected container.')
        } else {
          sendAssistantMessage(`Found ${itemCount} text item${itemCount === 1 ? '' : 's'}`)
          sendAssistantMessage('Table generated')
        }
        
        // Send table to UI
        figma.ui.postMessage({
          pluginMessage: {
            type: 'CONTENT_TABLE_GENERATED',
            table: contentTable
          }
        })
        
        console.log('[Main] Content table generated:', itemCount, 'items')
        return
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error'
        sendAssistantMessage(`Error: ${errorMessage}`)
        figma.notify(`Error generating table: ${errorMessage}`)
        
        figma.ui.postMessage({
          pluginMessage: {
            type: 'CONTENT_TABLE_ERROR',
            error: errorMessage
          }
        })
        return
      }
    } else if (actionId === 'copy-ref-image') {
      // Handle Copy Ref Image quick action
      // This will be handled via direct message from UI, not through quick action
      return
    }
  }
  
  // Special handling for Code2Design quick actions
  if (assistantId === 'code2design') {
    if (actionId === 'send-json' || actionId === 'get-json') {
      // These actions open modals in the UI, not handled here
      return
    }
    if (actionId === 'json-format-help') {
      // Send canned help message
      const helpMessage = `**FigmAI Template JSON Format**

**Schema Version:** 1.0

**Required Top-Level Keys:**
- \`schemaVersion\`: Must be "1.0"
- \`root\`: The root template node

**Supported Node Types (v1):**
- \`FRAME\`: Container with optional auto-layout
- \`TEXT\`: Text node with content
- \`RECTANGLE\`: Rectangle shape

**Safety Limits:**
- Maximum depth: 12 levels
- Maximum nodes: 300
- Invalid JSON will not modify the canvas

**Example Structure:**
\`\`\`json
{
  "schemaVersion": "1.0",
  "meta": { "name": "My Design" },
  "root": {
    "type": "FRAME",
    "name": "Card",
    "layout": { "mode": "AUTO_LAYOUT", "direction": "VERTICAL" },
    "children": [...]
  }
}
\`\`\`

Use SEND JSON to import or GET JSON to export your designs.`
      sendAssistantMessage(helpMessage)
      return
    }
  }
  
  // Check selection requirement (need to check before building context)
  const selection = summarizeSelection(selectionOrder)
  if (action.requiresSelection && !selection.hasSelection) {
    sendAssistantMessage(`Error: This action requires a selection. Please select one or more nodes first.`)
    return
  }
  
  // Check vision requirement
  if (action.requiresVision && !selection.hasSelection) {
    sendAssistantMessage(`Error: This action requires a selection to analyze. Please select a frame or design element first.`)
    return
  }
  
  // Note: "Analyzing..." message is now handled in UI before sending the action
  
  // Add user message (the template message from quick action)
  // This is the SINGLE source of truth for user messages - UI should NOT add it optimistically
  // to prevent duplicates (UI was adding it, then main sent it back, causing duplicate)
  const userMessage: Message = {
    id: generateMessageId(),
    role: 'user',
    content: action.templateMessage,
    timestamp: Date.now()
  }
  messageHistory.push(userMessage)
  
  // Send user message to UI (main thread is source of truth)
  console.log('[Main] Sending user message to UI (single source of truth):', userMessage.id)
  figma.ui.postMessage({ pluginMessage: { type: 'ASSISTANT_MESSAGE', message: userMessage } })
  
  // Handle tool-only assistants
  if (assistant.kind === 'tool') {
    sendAssistantMessage(`Tool-only assistant "${assistant.label}" is active. Tool execution would happen here.`)
    return
  }
  
  // Build chat messages
  // Filter and normalize messages for provider
  const chatMessages = normalizeMessages(
    messageHistory
      .filter(m => m.role === 'user' || m.role === 'assistant')
      .map(m => ({
        role: m.role,
        content: m.content
      }))
  )
  
  // Build selection context (includes state, summary, and images if needed)
  let selectionContext: Awaited<ReturnType<typeof buildSelectionContext>> | undefined
  if (!currentProvider) {
    currentProvider = await createProvider(currentProviderId)
  }
  selectionContext = await buildSelectionContext({
    selectionOrder,
    quickAction: action,
    provider: currentProvider
  })
  
  // Debug logging
  if (selectionContext.selectionSummary) {
    console.log('[Main] Selection summary for quick action:', selectionContext.selectionSummary.substring(0, 200) + '...')
  } else {
    console.log('[Main] No selection summary - hasSelection:', selectionContext.selection.hasSelection)
  }
  
  // Call provider with quick action context
  try {
    const response = await currentProvider.sendChat({
      messages: chatMessages,
      assistantId: assistant.id,
      assistantName: assistant.label,
      selection: action.requiresSelection ? selectionContext.selection : undefined,
      selectionSummary: selectionContext.selectionSummary,
      images: selectionContext.images,
      quickActionId: action.id
    })
    
    // Check if this is a Design Critique response and send to UI
    let designCritiqueHandled = false
    if (assistant.id === 'design_critique' && action.id === 'give-critique') {
      console.log('[Main] Processing Design Critique response, length:', response.length)
      designCritiqueHandled = true
      
      try {
        // Robust JSON extraction function
        const extractJsonObject = (text: string): string | null => {
          // Step 1: Try direct parse first
          try {
            JSON.parse(text.trim())
            return text.trim()
          } catch {
            // Continue to extraction
          }
          
          // Step 2: Strip common markdown wrappers
          let cleaned = text.trim()
          
          // Remove markdown code fences (```json ... ``` or ``` ... ```)
          cleaned = cleaned.replace(/^```json\s*/i, '').replace(/^```\s*/i, '').replace(/\s*```$/i, '').trim()
          
          // Remove leading/trailing whitespace and common prefixes
          cleaned = cleaned.replace(/^[\s\n\r]*/, '').replace(/[\s\n\r]*$/, '')
          
          // Step 3: Find first '{' and extract balanced JSON object
          const firstBrace = cleaned.indexOf('{')
          if (firstBrace === -1) {
            return null
          }
          
          let depth = 0
          let inString = false
          let escapeNext = false
          let start = firstBrace
          
          for (let i = firstBrace; i < cleaned.length; i++) {
            const char = cleaned[i]
            
            if (escapeNext) {
              escapeNext = false
              continue
            }
            
            if (char === '\\') {
              escapeNext = true
              continue
            }
            
            if (char === '"' && !escapeNext) {
              inString = !inString
              continue
            }
            
            if (!inString) {
              if (char === '{') {
                depth++
              } else if (char === '}') {
                depth--
                if (depth === 0) {
                  // Found balanced JSON object
                  return cleaned.substring(start, i + 1)
                }
              }
            }
          }
          
          return null
        }
        
        // Three-tier fallback: JSON → Markdown Parser → LLM Repair → Error
        let scorecardResult: ScorecardResult | null = null
        
        // Tier 1: Try JSON parsing (direct or extracted)
        let jsonString: string | null = null
        let parseMethod: 'direct' | 'extracted' = 'direct'
        
        try {
          // Try direct parse first
          JSON.parse(response.trim())
          jsonString = response.trim()
          parseMethod = 'direct'
        } catch {
          // Extract JSON object from response (never throws, returns null on failure)
          jsonString = extractJsonObject(response)
          if (jsonString) {
            parseMethod = 'extracted'
          }
        }
        
        if (jsonString) {
          console.log(`[DesignCritique] JSON ${parseMethod === 'direct' ? 'direct parse' : 'extraction'} succeeded`)
          
          try {
            const parsed = JSON.parse(jsonString)
            
            // Validate strict scorecard schema
            if (
              parsed.type === 'scorecard' &&
              typeof parsed.version === 'number' &&
              typeof parsed.summary === 'string' &&
              typeof parsed.overallScore === 'number' &&
              Array.isArray(parsed.items) &&
              Array.isArray(parsed.risks) &&
              Array.isArray(parsed.actions)
            ) {
              scorecardResult = {
                type: 'scorecard',
                version: parsed.version,
                summary: parsed.summary,
                overallScore: parsed.overallScore,
                items: parsed.items.map((item: any) => ({
                  label: String(item.label || ''),
                  score: Number(item.score || 0),
                  outOf: Number(item.outOf || 5),
                  notes: String(item.notes || '')
                })),
                risks: parsed.risks.map((r: any) => String(r)),
                actions: parsed.actions.map((a: any) => String(a))
              }
              console.log('[DesignCritique] Valid scorecard result parsed from JSON. Score:', scorecardResult.overallScore)
            } else {
              console.warn('[DesignCritique] JSON parsed but schema invalid. Expected type=scorecard, got:', parsed)
              // Fall through to markdown parser
            }
              } catch (parseError) {
            console.log('[DesignCritique] JSON parse failed -> trying markdown parser')
          }
        } else {
          console.log('[DesignCritique] JSON parse failed -> trying markdown parser')
        }
        
        // Tier 2: Try markdown parser if JSON failed
        if (!scorecardResult) {
          scorecardResult = parseDesignCritiqueMarkdown(response)
          if (scorecardResult) {
            console.log('[DesignCritique] Markdown parser succeeded. Score:', scorecardResult.overallScore)
            } else {
            console.log('[DesignCritique] Markdown parser failed')
          }
        }
        
        // Tier 3: Try LLM repair if both JSON and markdown parsing failed
        if (!scorecardResult) {
          console.log('[DesignCritique] Repair attempt starting')
          
          try {
            const repairResponse = await repairDesignCritiqueToJson(response, currentProvider)
            console.log('[DesignCritique] Repair attempt completed, length:', repairResponse.length)
            
            // Try to parse the repaired response
            let repairedJsonString: string | null = null
            let repairedParseMethod: 'direct' | 'extracted' = 'direct'
            
            try {
              JSON.parse(repairResponse.trim())
              repairedJsonString = repairResponse.trim()
              repairedParseMethod = 'direct'
            } catch {
              repairedJsonString = extractJsonObject(repairResponse)
              if (repairedJsonString) {
                repairedParseMethod = 'extracted'
              }
            }
            
            if (repairedJsonString) {
              console.log(`[DesignCritique] Repaired JSON ${repairedParseMethod === 'direct' ? 'direct parse' : 'extraction'} succeeded`)
              
              try {
                const repairedParsed = JSON.parse(repairedJsonString)
                
                // Validate strict scorecard schema
                if (
                  repairedParsed.type === 'scorecard' &&
                  typeof repairedParsed.version === 'number' &&
                  typeof repairedParsed.summary === 'string' &&
                  typeof repairedParsed.overallScore === 'number' &&
                  Array.isArray(repairedParsed.items) &&
                  Array.isArray(repairedParsed.risks) &&
                  Array.isArray(repairedParsed.actions)
                ) {
                  scorecardResult = {
                    type: 'scorecard',
                    version: repairedParsed.version,
                    summary: repairedParsed.summary,
                    overallScore: repairedParsed.overallScore,
                    items: repairedParsed.items.map((item: any) => ({
                      label: String(item.label || ''),
                      score: Number(item.score || 0),
                      outOf: Number(item.outOf || 5),
                      notes: String(item.notes || '')
                    })),
                    risks: repairedParsed.risks.map((r: any) => String(r)),
                    actions: repairedParsed.actions.map((a: any) => String(a))
                  }
                  console.log('[DesignCritique] Repair success! Valid scorecard result parsed. Score:', scorecardResult.overallScore)
        } else {
                  console.warn('[DesignCritique] Repaired JSON parsed but schema invalid')
                }
              } catch (repairedParseError) {
                console.error('[DesignCritique] Failed to parse repaired JSON:', repairedParseError)
        }
      } else {
              console.error('[DesignCritique] Repair response did not contain valid JSON')
            }
          } catch (repairError) {
            console.error('[DesignCritique] Repair attempt failed:', repairError)
          }
        }
        
        // If we have a valid scorecard result, render it
        if (scorecardResult) {
          // Send scorecard result to UI
          figma.ui.postMessage({
            pluginMessage: {
              type: 'SCORECARD_RESULT',
              payload: scorecardResult
            }
          })
          console.log('[DesignCritique] Sent SCORECARD_RESULT to UI')
          
          // Render scorecard on canvas if selection exists
          if (selectionContext.selection.hasSelection && selectionOrder.length > 0) {
            const selectedNode = figma.getNodeById(selectionOrder[0])
            if (selectedNode && selectedNode.type !== 'DOCUMENT' && selectedNode.type !== 'PAGE') {
              try {
                // Convert to legacy format for canvas rendering
                const legacyScorecardData: ScorecardData = {
                  score: scorecardResult.overallScore,
                  summary: scorecardResult.summary,
                  wins: scorecardResult.items.filter(i => i.score >= 4).map(i => i.label),
                  fixes: scorecardResult.items.filter(i => i.score < 3).map(i => `${i.label}: ${i.notes}`),
                  checklist: scorecardResult.items.map(i => i.label),
                  notes: scorecardResult.risks
                }
                await renderScorecard(legacyScorecardData, selectedNode as SceneNode)
                console.log('[DesignCritique] Scorecard frame rendered on canvas')
              } catch (canvasError) {
                console.error('[DesignCritique] Error rendering scorecard on canvas:', canvasError)
                // Send error but don't fail the whole operation
                figma.ui.postMessage({
                  pluginMessage: {
                    type: 'SCORECARD_ERROR',
                    error: `Failed to render scorecard on canvas: ${canvasError instanceof Error ? canvasError.message : 'Unknown error'}`,
                    raw: undefined
                  }
                })
              }
            }
          }
          
          // Update status message
          figma.ui.postMessage({
            pluginMessage: {
              type: 'SCORECARD_PLACED',
              success: true,
              message: 'Scorecard added to stage.'
            }
          })
            return
        }
        
        // Tier 4: All methods failed - show error
        console.error('[DesignCritique] All parsing methods failed (JSON, markdown, repair)')
        const errorMessage = 'Failed to parse design critique response. Tried JSON parsing, markdown parsing, and LLM repair.'
        
        // Send error to UI - do NOT create text frame or send response to chat
        figma.ui.postMessage({
          pluginMessage: {
            type: 'SCORECARD_ERROR',
            error: errorMessage,
            raw: response // Include full response so UI can show "Show raw response"
          }
        })
        console.log('[DesignCritique] Sent SCORECARD_ERROR to UI')
        
        // Update status to error
        figma.ui.postMessage({
          pluginMessage: {
            type: 'SCORECARD_PLACED',
            success: false,
            message: 'Could not parse scorecard. Check console for details.'
          }
        })
        return
      } catch (error) {
        // Outer catch for unexpected errors during parsing/rendering
        console.error('[DesignCritique] Unexpected error processing Design Critique:', error)
        const errorMessage = error instanceof Error 
          ? error.message 
          : 'Unknown error processing Design Critique response'
        
        // Log first 200 chars of response for debugging (Design Critique only)
        const responsePreview = response.substring(0, 200)
        console.log('[DesignCritique] Response preview (first 200 chars):', responsePreview)
        
        // Send error to UI - do NOT create text frame or send response to chat
        figma.ui.postMessage({
          pluginMessage: {
            type: 'SCORECARD_ERROR',
            error: `Design Critique error: ${errorMessage}`,
            raw: response // Include full response so UI can show "Show raw response"
          }
        })
        console.log('[DesignCritique] Sent SCORECARD_ERROR to UI')
        return
      } catch (error) {
        // Outer catch for unexpected errors during parsing/rendering
        console.error('[DesignCritique] Unexpected error processing Design Critique:', error)
        const errorMessage = error instanceof Error 
          ? error.message 
          : 'Unknown error processing Design Critique response'
        
        // Log first 200 chars of response for debugging (Design Critique only)
        const responsePreview = response.substring(0, 200)
        console.log('[DesignCritique] Response preview (first 200 chars):', responsePreview)
        
        // Send error to UI - do NOT create text frame or send response to chat
        figma.ui.postMessage({
          pluginMessage: {
            type: 'SCORECARD_ERROR',
            error: `Design Critique error: ${errorMessage}`,
            raw: response // Include full response so UI can show "Show raw response"
          }
        })
        console.log('[DesignCritique] Sent SCORECARD_ERROR to UI')
        return
      }
    }
    
    // Only send response to chat if NOT a Design Critique action (or if Design Critique handling failed)
    if (!designCritiqueHandled) {
      sendAssistantMessage(response)
    }
  } catch (error) {
    const errorMessage = errorToString(error)
    sendAssistantMessage(`Error: ${errorMessage}`)
  }
  } catch (error) {
    // Catch any unhandled errors in the quick action handler
    console.error('[Main] Unhandled error in RUN_QUICK_ACTION:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    sendAssistantMessage(`Error: ${errorMessage}`)
  }
})

// Handle run tool
on<RunToolHandler>('RUN_TOOL', async function (toolId: string, payload: Record<string, unknown>) {
  const selection = summarizeSelection(selectionOrder)
  const result = await routeToolCall(
    {
      id: generateMessageId(),
      name: toolId,
      arguments: payload
    },
    selection
  )
  
  // Extract JSON from export tool result
  let data: Record<string, unknown> | undefined
  if (toolId === 'EXPORT_SELECTION_TO_TEMPLATE_JSON' && result.startsWith('JSON_EXPORT:')) {
    try {
      const jsonString = result.replace('JSON_EXPORT:', '')
      data = { exportedJson: jsonString }
      // Update result message
      const message = result.includes('frame(s)') 
        ? `Exported ${selection?.count || 0} frame(s) to JSON template.`
        : 'Exported selection to JSON template.'
      sendToolResult(message, toolId, data)
      return
    } catch {
      // Fall through to normal result
    }
  }
  
  sendToolResult(result, toolId, data)
})

// Handle save settings
on<SaveSettingsHandler>('SAVE_SETTINGS', async function (settings: Record<string, unknown>) {
  try {
    await saveSettings(settings as Partial<import('./core/settings').Settings>)
    // Reinitialize provider with new settings
    currentProvider = await createProvider(currentProviderId)
  } catch (error) {
    const errorMessage = errorToString(error)
    figma.ui.postMessage({ 
      pluginMessage: { 
        type: 'TEST_RESULT', 
        success: false, 
        message: `Failed to save settings: ${errorMessage}` 
      } 
    })
  }
})

// Handle request settings
on<RequestSettingsHandler>('REQUEST_SETTINGS', async function () {
  try {
    const settings = await getSettings()
    figma.ui.postMessage({ 
      pluginMessage: { 
        type: 'SETTINGS_RESPONSE', 
        settings 
      } 
    })
  } catch (error) {
    figma.ui.postMessage({ 
      pluginMessage: { 
        type: 'SETTINGS_RESPONSE', 
        settings: await getSettings() // Return defaults on error
      } 
    })
  }
})

// Handle test proxy connection
on<TestProxyConnectionHandler>('TEST_PROXY_CONNECTION', async function () {
  try {
    if (!currentProvider) {
      currentProvider = await createProvider(currentProviderId)
    }
    const result = await currentProvider.testConnection()
    figma.ui.postMessage({ 
      pluginMessage: { 
        type: 'TEST_RESULT', 
        success: result.success, 
        message: result.message 
      } 
    })
  } catch (error) {
    const errorMessage = errorToString(error)
    figma.ui.postMessage({ 
      pluginMessage: { 
        type: 'TEST_RESULT', 
        success: false, 
        message: `Connection test failed: ${errorMessage}` 
      } 
    })
  }
})

// Handle copy table status from UI
on<CopyTableStatusHandler>('COPY_TABLE_STATUS', function (status: 'success' | 'error', message?: string) {
  console.log('[Main] onmessage COPY_TABLE_STATUS', { status, message })
  if (status === 'success') {
    figma.notify(message || 'Successfully copied table to clipboard')
  } else if (status === 'error') {
    figma.notify(message || 'Failed to copy table. See console for details.')
  }
})

// Initialize plugin
export default function () {
  showUI({
    height: 600,
    width: 400,
    title: BRAND.brandName
  })
  
  // Set up selection change listener
  figma.on('selectionchange', function () {
    // Update selection order: maintain order as items are selected/deselected
    const currentSelection = figma.currentPage.selection
    const currentIds = new Set(currentSelection.map(node => node.id))
    const previousIds = new Set(selectionOrder)
    
    // Remove deselected items from order
    selectionOrder = selectionOrder.filter(id => currentIds.has(id))
    
    // Add newly selected items to the end (right side) of the list
    for (const node of currentSelection) {
      if (!previousIds.has(node.id)) {
        // This is a newly selected item, append it
        selectionOrder.push(node.id)
      }
    }
    
    sendSelectionState()
  })
  
  // Initialize selection order
  const initialSelection = figma.currentPage.selection
  selectionOrder = initialSelection.map(node => node.id)
  
  // Send initial selection state
  sendSelectionState()
}

// Handle Export Content Table Ref Image
on<ExportContentTableRefImageHandler>('EXPORT_CONTENT_TABLE_REF_IMAGE', async function (rootNodeId: string) {
  console.log('[Main] EXPORT_CONTENT_TABLE_REF_IMAGE received', { rootNodeId })
  try {
    const node = figma.getNodeById(rootNodeId)
    if (!node) {
      console.error('[Main] Export Ref Image: Node not found for rootNodeId:', rootNodeId)
      figma.ui.postMessage({
        pluginMessage: {
          type: 'CONTENT_TABLE_REF_IMAGE_ERROR',
          message: 'Root node not found'
        }
      })
      return
    }
    
    if (node.type === 'DOCUMENT' || node.type === 'PAGE') {
      console.error('[Main] Export Ref Image: Cannot export document or page')
      figma.ui.postMessage({
        pluginMessage: {
          type: 'CONTENT_TABLE_REF_IMAGE_ERROR',
          message: 'Cannot export document or page as image'
        }
      })
      return
    }
    
    const sceneNode = node as SceneNode
    
    // Export as PNG, 600px wide
    // Try WIDTH constraint first, fallback to SCALE if needed
    let bytes: Uint8Array
    try {
      bytes = await sceneNode.exportAsync({
        format: 'PNG',
        constraint: {
          type: 'WIDTH',
          value: 600
        }
      })
    } catch (widthError) {
      // Fallback to SCALE if WIDTH constraint fails
      console.warn('[Main] Export Ref Image: WIDTH constraint failed, trying SCALE:', widthError)
      const nodeWidth = 'width' in sceneNode ? sceneNode.width : 600
      const scale = Math.min(1, 600 / nodeWidth)
      bytes = await sceneNode.exportAsync({
        format: 'PNG',
        constraint: {
          type: 'SCALE',
          value: scale
        }
      })
    }
    
    console.log('[Main] Export Ref Image: Export succeeded, bytes length:', bytes.length)
    
    // Convert to base64 data URL
    const base64 = figma.base64Encode(bytes)
    const dataUrl = `data:image/png;base64,${base64}`
    
    console.log('[Main] Export Ref Image: Sending READY, dataUrl length:', dataUrl.length)
    figma.ui.postMessage({
      pluginMessage: {
        type: 'CONTENT_TABLE_REF_IMAGE_READY',
        dataUrl: dataUrl
      }
    })
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    console.error('[Main] Export Ref Image: Failed to export ref image:', error)
    figma.ui.postMessage({
      pluginMessage: {
        type: 'CONTENT_TABLE_REF_IMAGE_ERROR',
        message: `Could not export reference image: ${errorMessage}`
      }
    })
  }
})
